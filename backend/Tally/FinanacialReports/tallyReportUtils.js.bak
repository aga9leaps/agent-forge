import axios from "axios";
import puppeteer from "puppeteer";
import { uploadFileToS3 } from "../s3Utils.js";
import dotenv from "dotenv";
import pdfParse from 'pdf-parse';

dotenv.config({ path: "../../configs/.env" });

const TALLY_URL = process.env.TALLY_URL;

// Mapping of user-friendly terms to technical report terms
const TERM_MAPPING = {
  // Profit & Loss terms - Basic metrics
  "profit margin": ["net profit %", "gross profit %"],
  "gross margin": ["gross profit %", "gross profit"],
  "net profit": ["net profit", "nett profit", "profit after tax"],
  "nett profit": ["net profit", "nett profit", "profit after tax"],
  "revenue": ["sales", "sales accounts", "total income", "total revenue"],
  "expenses": ["total expenses", "direct expenses", "indirect expenses"],
  "operating cost": ["operating cost %", "operating expenses"],
  "gross loss": ["gross loss", "gross loss b/f", "gross loss bf"],
  "gross loss b/f": ["gross loss b/f", "gross loss bf", "gross loss"],
  "gross loss brought forward": ["gross loss b/f", "gross loss bf", "gross loss"],
  
  // Profit & Loss terms - Stock and Materials
  "opening stock": ["opening stock"],
  "closing stock": ["closing stock", "finish goods", "closing stock finish goods"],
  "raw material": ["raw material", "raw materials"],
  "finished goods": ["finish goods", "finished goods"],
  
  // Profit & Loss terms - Purchases and Sales
  "purchase accounts": ["purchase accounts", "purchases account"],
  "sales accounts": ["sales accounts", "sales account"],
  "custom clearing": ["custom clearing expenses", "custom clearance"],
  "godown expenses": ["godown expenses", "godown exp"],
  "inward carting": ["inward carting below 750", "inward carting"],
  "loading charges": ["loading & unloading charge", "loading and unloading"],
  "mobile expenses": ["mobile expenses"],
  "outward freight": ["outward freight above 750", "outward freight"],
  "sales promotion": ["sales promotion a/c", "sales promotion"],
  
  // Profit & Loss terms - Discounts and fees
  "bill discount": ["bill discount"],
  "bill discount fee": ["bill discount fee"],
  "bill discount gst": ["bill discount gst"],
  "discount": ["discount", "bill discount"],
  "special discount": ["special discount"],
  "gst sales": ["gst sales", "gst sale"],
  
  // Profit & Loss terms - Indirect income and expenses
  "indirect incomes": ["indirect incomes"],
  "indirect expenses": ["indirect expenses"],
  "commission expenses": ["commission expenses"],
  "petrol expense": ["petrol expense"],
  "rates and tax": ["rates & tax", "rates and tax"],
  "tour expenses": ["tour exp", "tour expenses"],
  "transportation": ["transportation"],
  "salary": ["salary account"],
  "business management": ["business management and consultancy"],
  "consultancy": ["business management and consultancy"],
  
  // Ratio Analysis terms
  "current ratio": ["current ratio", "current assets : current liabilities"],
  "quick ratio": ["quick ratio", "current assets-stock-in-hand : current liabilities"],
  "debt/equity": ["debt/equity ratio", "loans (liability) : capital account + nett profit"],
  "gross profit %": ["gross profit %"],
  "net profit %": ["net profit %", "nett profit %"],
  "operating cost %": ["operating cost %"],
  "inventory turnover": ["inventory turnover", "sales accounts / closing stock"],
  "working capital turnover": ["wkg. capital turnover", "sales accounts / working capital"],
  "return on investment": ["return on investment %", "nett profit / capital account + nett profit"],
  "receivables turnover": ["recv. turnover in days", "receivables turnover", "debtors turnover"],
  "recv turnover": ["recv. turnover in days", "receivables turnover"],
  "receivables turnover in days": ["recv. turnover in days"],
  
  // Cash Flow Statement terms
  "cash inflow": ["inflow", "cash inflow"],
  "cash outflow": ["outflow", "cash outflow"],
  "net flow": ["net flow", "net cash flow"],
  
  // Expense Analysis terms
  "direct expenses": ["direct expenses"],
  "indirect expenses": ["indirect expenses"],
  "salary": ["salary account", "salary expenses"],
  "rent": ["rent", "rent expenses"],
  "marketing": ["marketing", "advertising", "promotion", "sales promotion"],
  "travel": ["tour exp", "travel expenses"],
  
  // Common financial metrics
  "total assets": ["total assets"],
  "liabilities": ["total liabilities", "liabilities"],
  "equity": ["equity", "capital account"],
};

// Report type detection from keywords
const REPORT_TYPE_KEYWORDS = {
  "profit_and_loss_report": [
    "profit", "loss", "p&l", "revenue", "expenses", "sales", "cost of goods sold", 
    "gross profit", "net profit", "operating profit", "income"
  ],
  "ratio_analysis_report": [
    "ratio", "current ratio", "quick ratio", "debt", "equity", "return on investment", 
    "roi", "working capital", "inventory turnover"
  ],
  "cash_flow_statement_report": [
    "cash flow", "statement", "inflow", "outflow", "cash movement", "cash balance"
  ],
  "cash_flow_projection_report": [
    "projection", "forecast", "cash flow projection", "future cash flow", "estimated cash flow"
  ],
  "expense_analysis_report": [
    "expense", "analysis", "expenditure", "spending", "costs", "direct expenses", 
    "indirect expenses", "operational costs"
  ]
};

export function formatDateRange(fromDate, toDate) {
  const format = (dateStr) => {
    const year = dateStr.substring(0, 4);
    const month = dateStr.substring(4, 6);
    const dateObj = new Date(`${year}-${month}-01`);
    return dateObj.toLocaleString('default', { month: 'long', year: 'numeric' });
  };
  return `${format(fromDate)} to ${format(toDate)}`;
}

// Function to extract text from PDF buffer
export async function extractTextFromPDF(pdfBuffer) {
  try {
    const data = await pdfParse(pdfBuffer);
    return data.text;
  } catch (error) {
    console.error("Error extracting text from PDF:", error);
    return null;
  }
}

// Function to parse PDF content into structured data
export async function parsePDFContent(pdfBuffer, reportType) {
  try {
    // Extract text from PDF
    const pdfText = await extractTextFromPDF(pdfBuffer);
    if (!pdfText) return null;
    
    // Convert to lowercase for easier matching
    const lowerText = pdfText.toLowerCase();
    
    // Extract key-value pairs using regex patterns
    const keyValuePairs = {};
    const lines = pdfText.split('\n').filter(line => line.trim());
    
    // Different parsing strategies based on report type
    switch (reportType) {
      case 'profit_and_loss_report':
        // Extract profit & loss specific data
        extractProfitLossData(lines, keyValuePairs);
        break;
      case 'ratio_analysis_report':
        // Extract ratio analysis specific data
        extractRatioAnalysisData(lines, keyValuePairs);
        break;
      case 'cash_flow_statement_report':
        // Extract cash flow statement specific data
        extractCashFlowStatementData(lines, keyValuePairs);
        break;
      case 'cash_flow_projection_report':
        // Extract cash flow projection specific data
        extractCashFlowProjectionData(lines, keyValuePairs);
        break;
      case 'expense_analysis_report':
        // Extract expense analysis specific data
        extractExpenseAnalysisData(lines, keyValuePairs);
        break;
      default:
        // Generic extraction for any report
        extractGenericData(lines, keyValuePairs);
    }
    
    // Store the raw text for fuzzy matching later
    keyValuePairs._rawText = pdfText;
    
    // Final pass: look for any key metrics that we might have missed by direct pattern matching
    // This is especially important for metrics like "gross loss b/f" which might have varied format
    function performFinalScanForMetrics(lines, keyValuePairs) {
      console.log("Performing final scan for important metrics that might have been missed");
      
      // List of important metrics to look for that might have been missed
      const criticalMetrics = [
        { key: 'gross_loss_bf', patterns: ['gross loss b/f', 'gross loss bf', 'gross loss brought forward'] },
        { key: 'gross_profit', patterns: ['gross profit'] },
        { key: 'gross_loss', patterns: ['gross loss'] },
        { key: 'net_profit', patterns: ['net profit', 'nett profit'] },
        { key: 'net_loss', patterns: ['net loss', 'nett loss'] },
        { key: 'sales_accounts', patterns: ['sales accounts', 'sales account'] },
        { key: 'purchase_accounts', patterns: ['purchase accounts', 'purchases account'] },
        { key: 'opening_stock', patterns: ['opening stock'] },
        { key: 'closing_stock', patterns: ['closing stock'] }
      ];
      
      // Check for each critical metric if we don't already have it
      for (const metric of criticalMetrics) {
        if (!keyValuePairs[metric.key]) {
          console.log(`Final scan: looking for missing metric ${metric.key}`);
          
          // Search for the patterns in all lines
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim().toLowerCase();
            
            for (const pattern of metric.patterns) {
              if (line.includes(pattern)) {
                console.log(`Final scan: found potential match for ${metric.key} at line ${i}: ${lines[i]}`);
                
                // Use our enhanced extractor
                const value = extractDataFromComplexPattern(lines, i, pattern.replace(/\s+/g, '\\s+'), 5);
                
                if (value) {
                  keyValuePairs[metric.key] = value;
                  console.log(`Final scan: successfully extracted ${metric.key} = ${value}`);
                  break;
                }
              }
            }
            
            // Stop if we found the metric
            if (keyValuePairs[metric.key]) break;
          }
        }
      }
      
      // Add a specific final scan for ratio analysis reports
      if (reportType === 'ratio_analysis_report') {
        // Additional critical metrics for ratio analysis
        const ratioAnalysisMetrics = [
          { key: 'receivables_turnover_days', patterns: ['recv. turnover in days', 'receivables turnover'] },
          { key: 'current_ratio', patterns: ['current ratio'] },
          { key: 'quick_ratio', patterns: ['quick ratio'] },
          { key: 'debt_equity_ratio', patterns: ['debt/equity ratio', 'debt equity'] },
        ];
        
        // Specifically scan for the receivables turnover metric which can be hard to extract
        for (const metric of ratioAnalysisMetrics) {
          if (!keyValuePairs[metric.key]) {
            console.log(`Final ratio scan: looking for missing metric ${metric.key}`);
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              const lowerLine = line.toLowerCase();
              
              for (const pattern of metric.patterns) {
                if (lowerLine.includes(pattern)) {
                  console.log(`Found match for ${metric.key} in line: "${line}"`);
                  
                  // For receivables turnover, look for the days value specifically
                  if (metric.key === 'receivables_turnover_days') {
                    // First check if the value is on the same line
                    let daysMatch = line.match(/(\d+\.\d+|\d+)[\s]*days/i);
                    if (daysMatch) {
                      keyValuePairs[metric.key] = daysMatch[1] + " days";
                      console.log(`Extracted ${metric.key}: ${keyValuePairs[metric.key]}`);
                    } 
                    // Then check if the value is at the far right of the line (as in a table cell)
                    else {
                      const valueMatch = line.match(/.*?(\d+\.\d+|\d+)\s*$/);
                      if (valueMatch) {
                        keyValuePairs[metric.key] = valueMatch[1] + " days";
                        console.log(`Extracted ${metric.key}: ${keyValuePairs[metric.key]}`);
                      }
                      // If still not found, check the next line
                      else if (i < lines.length - 1) {
                        const nextLine = lines[i+1].trim();
                        const numMatch = nextLine.match(/^[\s]*(\d+\.\d+|\d+)[\s]*$/);
                        if (numMatch) {
                          keyValuePairs[metric.key] = numMatch[1] + " days";
                          console.log(`Extracted ${metric.key} from next line: ${keyValuePairs[metric.key]}`);
                        }
                      }
                    }
                  }
                  // For other metrics, use the standard extraction
                  else {
                    const value = extractNumbersFromLine(line) || 
                                  (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
                    if (value) {
                      keyValuePairs[metric.key] = value;
                      console.log(`Extracted ${metric.key}: ${value}`);
                    }
                  }
                  
                  break;
                }
              }
              
              if (keyValuePairs[metric.key]) break;
            }
          }
        }
      }
    }
    
    // Run the final scan to catch any missed metrics
    performFinalScanForMetrics(lines, keyValuePairs);
    
    return keyValuePairs;
  } catch (error) {
    console.error(`Error parsing ${reportType} content:`, error);
    return null;
  }
}

// Helper function to extract profit & loss data
function extractProfitLossData(lines, keyValuePairs) {
  // First, do a complete scan to find key section headers and their positions
  const sectionPositions = {};
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim().toLowerCase();
    
    // Find major section headers
    if (line.includes('gross profit') || line.includes('gross loss')) {
      sectionPositions.grossProfit = i;
    }
    else if (line.includes('net profit') || line.includes('nett profit') || 
             line.includes('net loss') || line.includes('nett loss')) {
      sectionPositions.netProfit = i;
    }
    else if (line.includes('direct expenses')) {
      sectionPositions.directExpenses = i;
    }
    else if (line.includes('indirect expenses')) {
      sectionPositions.indirectExpenses = i;
    }
  }
  
  console.log("Found section positions:", sectionPositions);
  
  // Process line by line to extract key financial metrics
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const lowerLine = line.toLowerCase();
    
    // GROSS PROFIT/LOSS SECTION
    if (lowerLine.includes('gross profit') || lowerLine.includes('gross loss')) {
      // First try to extract from the same line
      let valueMatch = extractNumbersFromLine(line);
      
      // If not found, try the next few lines
      if (!valueMatch && i < lines.length - 1) valueMatch = extractNumbersFromLine(lines[i+1]);
      if (!valueMatch && i < lines.length - 2) valueMatch = extractNumbersFromLine(lines[i+2]);
      
      if (valueMatch) {
        const keyName = lowerLine.includes('loss') ? 'gross_loss' : 'gross_profit';
        keyValuePairs[keyName] = valueMatch;
        console.log(`Extracted ${keyName}:`, valueMatch);
      }
    }    // Specific case for Gross Loss b/f which appears in the screenshot
    else if (lowerLine.includes('gross loss b/f') || lowerLine.includes('gross loss b/') || 
             lowerLine.includes('gross loss bf') || lowerLine.includes('gross loss brought forward')) {
      
      // First use our enhanced pattern extractor
      let valueMatch = extractDataFromComplexPattern(lines, i, 'gross\\s*loss\\s*(?:b\\/f|bf|brought\\s*forward)', 3);
      
      // Fallbacks if the pattern extractor didn't work
      if (!valueMatch) {
        valueMatch = extractNumbersFromLine(line);
        if (!valueMatch && i < lines.length - 1) valueMatch = extractNumbersFromLine(lines[i+1]);
        if (!valueMatch && i < lines.length - 2) valueMatch = extractNumbersFromLine(lines[i+2]);
      }
      
      // Look for specific formatting in the line
      if (!valueMatch) {
        // Try with regex patterns suited for Tally reports
        const patterns = [
          /(gross\s*loss\s*b\/f|gross\s*loss\s*bf|gross\s*loss\s*brought\s*forward).*?([\d,.]+)/i,
          /gross\s*loss\s*(?:b\/f|bf|brought\s*forward).*?\n.*?([\d,.]+)/i,
          /gross\s*loss\s*(?:b\/f|bf|brought\s*forward)/i
        ];
        
        for (const regex of patterns) {
          const match = line.match(regex);
          if (match && match[2]) {
            valueMatch = match[2];
            break;
          }
        }
        
        // If still not found, check nearby rows that might contain just the value
        if (!valueMatch) {
          // Check previous line for just a number
          if (i > 0) {
            const prevLine = lines[i-1].trim();
            if (/^[\s\d,.]+$/.test(prevLine)) { // Only contains digits, dots, commas, and whitespace
              valueMatch = extractNumbersFromLine(prevLine);
            }
          }
          
          // Check next line for just a number
          if (!valueMatch && i < lines.length - 1) {
            const nextLine = lines[i+1].trim();
            if (/^[\s\d,.]+$/.test(nextLine)) {
              valueMatch = extractNumbersFromLine(nextLine);
            }
          }
        }
      }
      
      if (valueMatch) {
        keyValuePairs['gross_loss_bf'] = valueMatch;
        console.log("Extracted gross loss b/f:", valueMatch);
      } else {
        console.warn("Failed to extract gross loss b/f near line:", line);
      }
    }
    // NET PROFIT/LOSS SECTION
    else if (lowerLine.includes('net profit') || lowerLine.includes('nett profit') || 
             lowerLine.includes('net loss') || lowerLine.includes('nett loss')) {
      
      // First try to extract from the same line
      let valueMatch = extractNumbersFromLine(line);
      
      // If not found, try the next few lines
      if (!valueMatch && i < lines.length - 1) valueMatch = extractNumbersFromLine(lines[i+1]);
      if (!valueMatch && i < lines.length - 2) valueMatch = extractNumbersFromLine(lines[i+2]);
      
      // Try with regex that's more specific for P&L reports
      if (!valueMatch) {
        const profitMatch = line.match(/(net\s*profit|nett\s*profit|net\s*loss|nett\s*loss).*?([\d,.]+)/i);
        if (profitMatch) valueMatch = profitMatch[2];
      }
      
      if (valueMatch) {
        keyValuePairs['net_profit'] = valueMatch;
        console.log("Extracted net profit:", valueMatch);
        
        // Also store as nett_profit for alternative spelling
        keyValuePairs['nett_profit'] = valueMatch;
      }
    }
    // SALES ACCOUNTS SECTION
    else if (lowerLine.includes('sales account') || lowerLine.includes('sales accounts')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['sales_accounts'] = valueMatch;
        console.log("Extracted sales accounts:", valueMatch);
      }
    }
    // EXPENSES SECTION
    else if (lowerLine.includes('total expenses') || 
             lowerLine.includes('direct expenses') ||
             lowerLine.includes('indirect expenses')) {
      const valueMatch = extractNumbersFromLine(line) || 
                         (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      const key = lowerLine.includes('direct') ? 'direct_expenses' :
                 lowerLine.includes('indirect') ? 'indirect_expenses' : 'total_expenses';
      if (valueMatch) {
        keyValuePairs[key] = valueMatch;
        console.log(`Extracted ${key}:`, valueMatch);
      }
    }
    
    // Extract other key P&L metrics based on your screenshot
    
    // OPENING/CLOSING STOCK
    else if (lowerLine.includes('opening stock')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['opening_stock'] = valueMatch;
        console.log("Extracted opening stock:", valueMatch);
      }
    }
    else if (lowerLine.includes('closing stock')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['closing_stock'] = valueMatch;
        console.log("Extracted closing stock:", valueMatch);
      }
    }
    
    // RAW MATERIALS
    else if (lowerLine.includes('raw material')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['raw_material'] = valueMatch;
        console.log("Extracted raw material:", valueMatch);
      }
    }
    
    // PURCHASE ACCOUNTS
    else if (lowerLine.includes('purchase accounts') || lowerLine.includes('purchases account')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['purchase_accounts'] = valueMatch;
        console.log("Extracted purchase accounts:", valueMatch);
      }
    }
    
    // DIRECT AND SPECIFIC EXPENSES
    else if (lowerLine.includes('custom clearing expenses') || lowerLine.includes('custom clearance')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['custom_clearing_expenses'] = valueMatch;
        console.log("Extracted custom clearing expenses:", valueMatch);
      }
    }
    else if (lowerLine.includes('godown expenses')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['godown_expenses'] = valueMatch;
        console.log("Extracted godown expenses:", valueMatch);
      }
    }
    else if (lowerLine.includes('inward carting below 750') || lowerLine.includes('inward carting')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['inward_carting'] = valueMatch;
        console.log("Extracted inward carting:", valueMatch);
      }
    }
    else if (lowerLine.includes('loading & unloading charge') || lowerLine.includes('loading and unloading')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['loading_unloading'] = valueMatch;
        console.log("Extracted loading & unloading charges:", valueMatch);
      }
    }
    else if (lowerLine.includes('mobile expenses')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['mobile_expenses'] = valueMatch;
        console.log("Extracted mobile expenses:", valueMatch);
      }
    }
    else if (lowerLine.includes('outward freight above 750') || lowerLine.includes('outward freight')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['outward_freight'] = valueMatch;
        console.log("Extracted outward freight:", valueMatch);
      }
    }
    else if (lowerLine.includes('sales promotion a/c') || lowerLine.includes('sales promotion')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['sales_promotion'] = valueMatch;
        console.log("Extracted sales promotion:", valueMatch);
      }
    }
    
    // INDIRECT INCOMES/EXPENSES
    else if (lowerLine.includes('indirect incomes')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['indirect_incomes'] = valueMatch;
        console.log("Extracted indirect incomes:", valueMatch);
      }
    }
    
    // COMMISSION, PETROL, RATES & TAX
    else if (lowerLine.includes('commission expenses')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['commission_expenses'] = valueMatch;
        console.log("Extracted commission expenses:", valueMatch);
      }
    }
    else if (lowerLine.includes('petrol expense')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['petrol_expense'] = valueMatch;
        console.log("Extracted petrol expense:", valueMatch);
      }
    }
    else if (lowerLine.includes('rates & tax')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['rates_tax'] = valueMatch;
        console.log("Extracted rates & tax:", valueMatch);
      }
    }
    
    // TOUR, TRANSPORT, SALARY
    else if (lowerLine.includes('tour exp')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['tour_expenses'] = valueMatch;
        console.log("Extracted tour expenses:", valueMatch);
      }
    }
    else if (lowerLine.includes('transportation')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['transportation'] = valueMatch;
        console.log("Extracted transportation:", valueMatch);
      }
    }
    else if (lowerLine.includes('salary account')) {
      const valueMatch = extractNumbersFromLine(line) || 
                        (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
      if (valueMatch) {
        keyValuePairs['salary_account'] = valueMatch;
        console.log("Extracted salary account:", valueMatch);
      }
    }
    
    // DISCOUNTS
    else if (lowerLine.includes('discount') && lowerLine.includes('%') && !lowerLine.includes('bill')) {
      // Extract discount percentages
      const percentMatch = line.match(/(\d+)\s*%/);
      if (percentMatch) {
        const percentage = percentMatch[1];
        const valueMatch = extractNumbersFromLine(line) || 
                          (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
        if (valueMatch) {
          keyValuePairs[`discount_${percentage}_percent`] = valueMatch;
          console.log(`Extracted ${percentage}% discount:`, valueMatch);
        }
      }
    }
  }
  
  // Second pass to extract any specific labels seen in the screenshot
  const specificLabels = [
    'bill discount', 'bill discount fee', 'bill discount gst', 
    'business management and consultancy', 'interest cost', 'gst sales', 
    'gst sale', 'special discount', 'sales bills to make'
  ];
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const lowerLine = line.toLowerCase();
    
    for (const label of specificLabels) {
      if (lowerLine.includes(label)) {
        const valueMatch = extractNumbersFromLine(line) || 
                          (i < lines.length - 1 ? extractNumbersFromLine(lines[i+1]) : null);
        if (valueMatch) {
          const keyName = label.replace(/\s+/g, '_');
          keyValuePairs[keyName] = valueMatch;
          console.log(`Extracted ${label}:`, valueMatch);
        }
        break; // Found a match for this line
      }
    }
  }
}

// Helper function to extract ratio analysis data
function extractRatioAnalysisData(lines, keyValuePairs) {
  // Process line by line to extract ratios
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const lowerLine = line.toLowerCase();
    
    // Extract common ratios
    if (lowerLine.includes('current ratio')) {
      const valueMatch = extractRatioValue(line) || extractRatioValue(lines[i+1]);
      if (valueMatch) keyValuePairs['current_ratio'] = valueMatch;
    }
    else if (lowerLine.includes('quick ratio')) {
      const valueMatch = extractRatioValue(line) || extractRatioValue(lines[i+1]);
      if (valueMatch) keyValuePairs['quick_ratio'] = valueMatch;
    }
    else if (lowerLine.includes('debt/equity ratio') || lowerLine.includes('debt equity')) {
      const valueMatch = extractRatioValue(line) || extractRatioValue(lines[i+1]);
      if (valueMatch) keyValuePairs['debt_equity_ratio'] = valueMatch;
    }
    else if (lowerLine.includes('gross profit %')) {
      const valueMatch = extractPercentageValue(line) || extractPercentageValue(lines[i+1]);
      if (valueMatch) keyValuePairs['gross_profit_percentage'] = valueMatch;
    }
    else if (lowerLine.includes('net profit %') || lowerLine.includes('nett profit %')) {
      const valueMatch = extractPercentageValue(line) || extractPercentageValue(lines[i+1]);
      if (valueMatch) keyValuePairs['net_profit_percentage'] = valueMatch;
    }
    else if (lowerLine.includes('operating cost %')) {
      const valueMatch = extractPercentageValue(line) || extractPercentageValue(lines[i+1]);
      if (valueMatch) keyValuePairs['operating_cost_percentage'] = valueMatch;
    }
    else if (lowerLine.includes('return on investment')) {
      const valueMatch = extractPercentageValue(line) || extractPercentageValue(lines[i+1]);
      if (valueMatch) keyValuePairs['roi_percentage'] = valueMatch;
    }    // Add support for Receivables Turnover
    else if (lowerLine.includes('recv. turnover') || lowerLine.includes('receivables turnover')) {
      let valueMatch = null;
      let hasNegativeIndicator = lowerLine.includes('(-)') || 
                               lowerLine.includes('(-') || 
                               (lowerLine.includes('(') && lowerLine.includes(')'));
      
      // For values that might have "days" at the end
      if (lowerLine.includes('in days')) {
        // First, clean the line of HTML tags
        const cleanLine = line.replace(/<[^>]*>/g, '');
        
        // Try to extract with days pattern
        const daysMatch = cleanLine.match(/([-+]?[\d.,]+)\s*days/i);
        if (daysMatch) {
          let value = daysMatch[1];
          // Apply negative sign if indicated
          if (hasNegativeIndicator && !value.startsWith('-')) {
            valueMatch = "-" + value + " days";
          } else {
            valueMatch = value + " days";
          }
        } else {
          // Try a more general approach
          const numberMatch = extractNumbersFromLine(line);
          if (numberMatch) valueMatch = numberMatch + " days";
        }
      } else {
        valueMatch = extractNumbersFromLine(line);
        if (valueMatch && !valueMatch.includes('days')) valueMatch += " days";
      }
      
      // If not found on current line, check next line
      if (!valueMatch && i < lines.length - 1) {
        const nextLine = lines[i+1].trim().toLowerCase();
        hasNegativeIndicator = hasNegativeIndicator || 
                              nextLine.includes('(-)') || 
                              nextLine.includes('(-') || 
                              (nextLine.includes('(') && nextLine.includes(')'));
                              
        if (nextLine.match(/^\s*[\d.,]+\s*days?\s*$/i)) {
          // Apply negative sign if indicated but not already present
          let value = nextLine.trim();
          if (hasNegativeIndicator && !value.startsWith('-')) {
            valueMatch = "-" + value;
          } else {
            valueMatch = value;
          }
        } else {
          valueMatch = extractNumbersFromLine(lines[i+1]);
          if (valueMatch && !valueMatch.includes('days')) valueMatch += " days";
        }
      }
      
      if (valueMatch) {
        keyValuePairs['receivables_turnover_days'] = valueMatch;
        console.log("Extracted receivables turnover in days:", valueMatch);
      }
    }
    else if (lowerLine.includes('receivables turnover')) {
      const valueMatch = extractRatioValue(line) || extractRatioValue(lines[i+1]);
      if (valueMatch) keyValuePairs['receivables_turnover'] = valueMatch;
    }
  }
}

// Helper function to extract cash flow statement data
function extractCashFlowStatementData(lines, keyValuePairs) {
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const lowerLine = line.toLowerCase();
    
    if (lowerLine.includes('inflow')) {
      const valueMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
      if (valueMatch) keyValuePairs['cash_inflow'] = valueMatch;
    }
    else if (lowerLine.includes('outflow')) {
      const valueMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
      if (valueMatch) keyValuePairs['cash_outflow'] = valueMatch;
    }
    else if (lowerLine.includes('net flow')) {
      const valueMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
      if (valueMatch) keyValuePairs['net_flow'] = valueMatch;
    }
  }
}

// Helper function to extract cash flow projection data
function extractCashFlowProjectionData(lines, keyValuePairs) {
  // Cash flow projection typically has multiple time periods
  // We'll extract key metrics for each month/period
  
  let currentPeriod = null;
  const periods = {};
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const lowerLine = line.toLowerCase();
    
    // Look for period headers (dates)
    const periodMatch = line.match(/(\d{1,2}[-/]\w{3}[-/]\d{2})\s+to\s+(\d{1,2}[-/]\w{3}[-/]\d{2})/i);
    if (periodMatch) {
      currentPeriod = `${periodMatch[1]}_to_${periodMatch[2]}`;
      periods[currentPeriod] = {};
      continue;
    }
    
    if (currentPeriod) {
      // Extract values for the current period
      if (lowerLine.includes('current balance') || lowerLine.includes('bank accounts')) {
        const valueMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
        if (valueMatch) periods[currentPeriod]['current_balance'] = valueMatch;
      }
      else if (lowerLine.includes('receivables')) {
        const valueMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
        if (valueMatch) periods[currentPeriod]['receivables'] = valueMatch;
      }
      else if (lowerLine.includes('payables')) {
        const valueMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
        if (valueMatch) periods[currentPeriod]['payables'] = valueMatch;
      }
      else if (lowerLine.includes('net balance')) {
        const valueMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
        if (valueMatch) periods[currentPeriod]['net_balance'] = valueMatch;
      }
    }
  }
  
  // Add all periods to the result
  keyValuePairs['periods'] = periods;
}

// Helper function to extract expense analysis data
function extractExpenseAnalysisData(lines, keyValuePairs) {
  let inDirectExpenses = false;
  let inIndirectExpenses = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const lowerLine = line.toLowerCase();
    
    // Track which section we're in
    if (lowerLine.includes('direct expenses')) {
      inDirectExpenses = true;
      inIndirectExpenses = false;
      const totalMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
      if (totalMatch) keyValuePairs['total_direct_expenses'] = totalMatch;
      continue;
    }
    else if (lowerLine.includes('indirect expenses')) {
      inDirectExpenses = false;
      inIndirectExpenses = true;
      const totalMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
      if (totalMatch) keyValuePairs['total_indirect_expenses'] = totalMatch;
      continue;
    }
    
    // Extract expense items based on the section
    if (inDirectExpenses) {
      // Extract direct expense items
      if (lowerLine.includes('custom clearing expenses')) {
        const valueMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
        if (valueMatch) keyValuePairs['custom_clearing_expenses'] = valueMatch;
      }
      else if (lowerLine.includes('godown expenses')) {
        const valueMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
        if (valueMatch) keyValuePairs['godown_expenses'] = valueMatch;
      }
      // Add more direct expense types as needed
    }
    else if (inIndirectExpenses) {
      // Extract indirect expense items
      if (lowerLine.includes('commission expenses')) {
        const valueMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
        if (valueMatch) keyValuePairs['commission_expenses'] = valueMatch;
      }
      else if (lowerLine.includes('petrol expense')) {
        const valueMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
        if (valueMatch) keyValuePairs['petrol_expense'] = valueMatch;
      }
      else if (lowerLine.includes('salary account')) {
        const valueMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
        if (valueMatch) keyValuePairs['salary_account'] = valueMatch;
      }
      else if (lowerLine.includes('rates & tax')) {
        const valueMatch = extractNumbersFromLine(line) || extractNumbersFromLine(lines[i+1]);
        if (valueMatch) keyValuePairs['rates_tax'] = valueMatch;
      }
      // Add more indirect expense types as needed
    }
  }
}

// Helper function to extract generic data from any report type
function extractGenericData(lines, keyValuePairs) {
  // Look for patterns that resemble financial data: label followed by numbers or percentages
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;
    
    // Skip header/footer lines and lines with page numbers
    if (line.match(/^page\s+\d+\s+of\s+\d+$/i) || line.match(/^\d+$/)) continue;
    
    // Look for label: value patterns
    const keyValueMatch = line.match(/^(.*?)[:]\s*([\d,.()-]+)$/);
    if (keyValueMatch) {
      const key = keyValueMatch[1].trim().toLowerCase().replace(/\s+/g, '_');
      const value = keyValueMatch[2].trim();
      keyValuePairs[key] = value;
      continue;
    }
    
    // Look for label value patterns (without colon)
    const simpleKeyValueMatch = line.match(/^([a-z\s&]+)\s+([\d,.()-]+)$/i);
    if (simpleKeyValueMatch) {
      const key = simpleKeyValueMatch[1].trim().toLowerCase().replace(/\s+/g, '_');
      const value = simpleKeyValueMatch[2].trim();
      keyValuePairs[key] = value;
      continue;
    }
  }
}

// Enhanced function to extract values from complex line patterns commonly found in financial reports
function extractDataFromComplexPattern(lines, startIndex, searchPattern, lineLimit = 3) {
  console.log(`Searching for complex pattern: ${searchPattern}`);
  const searchRegex = new RegExp(searchPattern, 'i');
  
  // Look in the current line and next few lines based on the limit
  for (let i = startIndex; i < startIndex + lineLimit && i < lines.length; i++) {
    const currentLine = lines[i].trim();
    if (searchRegex.test(currentLine)) {
      console.log(`Found match on line ${i}: ${currentLine}`);
      
      // Try to extract from the current line
      let valueMatch = extractNumbersFromLine(currentLine);
      if (valueMatch) return valueMatch;
      
      // Check if the value might be on the next line
      if (i < lines.length - 1) {
        const nextLine = lines[i + 1].trim();
        // If the next line only has numbers and no letters, it's likely our value
        if (/^[\s\d,.]+$/.test(nextLine)) {
          valueMatch = extractNumbersFromLine(nextLine);
          if (valueMatch) return valueMatch;
        }
      }
      
      // Try with specific pattern: Look for values after the search term
      const patternMatch = currentLine.match(new RegExp(`${searchPattern}.*?([\d,.]+)`, 'i'));
      if (patternMatch && patternMatch[1]) return patternMatch[1];
      
      // Finally, look for any number in the current line
      const anyNumber = currentLine.match(/([\d,.]+)/);
      if (anyNumber && anyNumber[1]) return anyNumber[1];
    }
  }
  
  return null;
}

// Helper functions to extract values from text
export function extractNumbersFromLine(line) {
  if (!line) return null;
  
  // Remove HTML tags for cleaner processing
  const cleanLine = line.replace(/<[^>]*>/g, '').trim();
  
  // Check if the line contains "(-)" pattern which indicates a negative value
  const hasNegativeIndicator = cleanLine.includes("(-)") || 
                             cleanLine.includes("(-") || 
                             (cleanLine.includes("(") && cleanLine.includes(")"));
    // Specific case for "(-)" format which is common in Tally reports
  if (cleanLine.includes("(-)")) {
    // Match any number that follows "(-)" pattern
    const negMatch = cleanLine.match(/\(-\)\s*([\d.,]+)/);
    if (negMatch) {
      return "-" + negMatch[1].trim();
    }
  }
    // First try to find currency amounts with rupee symbol
  let match = cleanLine.match(/(?:Rs\.?|â‚¹)\s*([-+]?\s*[\d,.-]+)/);
  if (match) {
    let value = match[1].trim();
    return hasNegativeIndicator && !value.startsWith('-') ? "-" + value : value;
  }
  
  // Look for parenthesized values which indicate negative numbers in accounting
  match = cleanLine.match(/\(([\d,.-]+)\)/);
  if (match) {
    return "-" + match[1].trim();
  }
    // If that fails, try to find any numeric value, preserving negative signs
  match = cleanLine.match(/([-+]?\s*[\d,.-]+)/);
  if (match) {
    let value = match[1].trim();
    // If there's a negative indicator but the matched number doesn't start with a minus
    if (hasNegativeIndicator && !value.startsWith('-')) {
      return "-" + value;
    }
    return value;
  }
  
  // For really messy data, try to extract numbers at the end of a line
  match = cleanLine.match(/.*?([-+]?\s*[\d,.-]+)$/);
  if (match) {
    let value = match[1].trim();
    return hasNegativeIndicator && !value.startsWith('-') ? "-" + value : value;
  }
  
  return null;
}

export function extractRatioValue(line) {
  if (!line) return null;
  
  // Try to find ratio format X : Y
  const match = line.match(/(\d+\.?\d*)\s*:\s*(\d+\.?\d*)/);
  if (match) return `${match[1]}:${match[2]}`;
  
  // Try to find decimal ratio format
  const decimalMatch = line.match(/([\d.-]+)/);
  if (decimalMatch) return decimalMatch[1];
  
  return null;
}

export function extractPercentageValue(line) {
  if (!line) return null;
  
  // Remove HTML tags for cleaner processing
  const cleanLine = line.replace(/<[^>]*>/g, '');
  
  console.log("Extracting percentage value from:", cleanLine);
  
  // Enhanced negative indicator detection
  const hasNegativeIndicator = cleanLine.includes("(-)") || 
                             cleanLine.includes("(-") || 
                             cleanLine.includes("-") ||
                             (cleanLine.includes("(") && cleanLine.includes(")")) ||
                             /\(\d+\.?\d*\)/.test(cleanLine); // Negative accounting format (XX.XX)
  
  console.log("Negative indicator detected:", hasNegativeIndicator);
  
  // Try to extract numbers within parentheses first (accounting notation for negative)
  const parenthesesMatch = cleanLine.match(/\((\d+\.?\d*)\)%?/);
  if (parenthesesMatch) {
    const value = parenthesesMatch[1].trim();
    console.log("Extracted negative percentage from parentheses:", value);
    return `-${value}%`;
  }
  
  // Find percentage with % symbol, preserving negative signs
  const match = cleanLine.match(/(-?\s*\d+\.?\d*)%/);
  if (match) {
    let value = match[1].trim().replace(/\s+/g, '');
    // If there's a negative indicator but the matched percentage doesn't start with a minus
    if (hasNegativeIndicator && !value.startsWith('-')) {
      console.log("Found percentage and applying negative indicator:", value);
      return `-${value}%`;
    }
    console.log("Found percentage value:", value);
    return `${value}%`;
  }
  
  // Try other number formats followed by % (with possible spaces)
  const looseMatch = cleanLine.match(/([-+]?\s*\d+\.?\d*)\s*%/);
  if (looseMatch) {
    let value = looseMatch[1].trim().replace(/\s+/g, '');
    if (hasNegativeIndicator && !value.startsWith('-')) {
      return `-${value}%`;
    }
    return `${value}%`;
  }
  
  // If that fails, try to find decimals that could be percentages
  const decimalMatch = cleanLine.match(/([-+]?\s*[0]?\.\d+)/);
  if (decimalMatch) {
    // Convert decimal to percentage (e.g., 0.15 -> 15%)
    let value = decimalMatch[1].trim().replace(/\s+/g, '');
    const percentage = Math.round(parseFloat(value) * 100);
    
    // Apply negative sign if indicated but not already in the value
    if (hasNegativeIndicator && !value.startsWith('-')) {
      console.log("Found decimal and applying negative indicator:", percentage);
      return `-${Math.abs(percentage)}%`;
    }
    console.log("Found decimal percentage value:", percentage);
    return `${percentage}%`;
  }
  
  // Last resort: try to find any number that might be a percentage
  const anyNumberMatch = cleanLine.match(/([-+]?\s*\d+\.?\d*)/);
  if (anyNumberMatch && cleanLine.toLowerCase().includes('percent')) {
    let value = anyNumberMatch[1].trim().replace(/\s+/g, '');
    if (hasNegativeIndicator && !value.startsWith('-')) {
      return `-${value}%`;
    }
    return `${value}%`;
  }
  
  console.log("No percentage value found in line");
  return null;
}

// Function to find matching metric based on user query
export function findMatchingMetric(pdfData, query) {
  if (!pdfData || !query) return null;
  
  console.log("Searching for metric in parsed data:", query);
  console.log("Available keys in parsed data:", Object.keys(pdfData).filter(k => k !== '_rawText'));
  
  // Helper function to clean values of HTML tags
  const cleanValue = (value) => {
    if (!value) return value;
    // Remove HTML tags and clean up any double spaces
    return value.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
  };
  
  // Lowercase and normalize the query for easier matching
  const lowerQuery = query.toLowerCase();
    // Special handling for profit margin - this is a common request with special mapping
  if (lowerQuery.includes('profit margin')) {
    console.log("Special handling for profit margin metric");
    
    // First try net profit percentage (primary metric for profit margin)
    if (pdfData['net_profit_percentage']) {
      let cleanedValue = cleanValue(pdfData['net_profit_percentage']);
      
      // Make sure it includes the % symbol
      if (!cleanedValue.includes('%')) {
        cleanedValue = cleanedValue + '%';
      }
      
      console.log("Found net_profit_percentage for profit margin:", cleanedValue);
      return {
        key: 'net_profit_percentage',
        value: cleanedValue,
        exact: true,
        displayName: 'Profit Margin'
      };
    }
    
    // Then try gross profit percentage as fallback
    if (pdfData['gross_profit_percentage']) {
      let cleanedValue = cleanValue(pdfData['gross_profit_percentage']);
      
      // Make sure it includes the % symbol
      if (!cleanedValue.includes('%')) {
        cleanedValue = cleanedValue + '%';
      }
      
      console.log("Found gross_profit_percentage as fallback for profit margin:", cleanedValue);
      return {
        key: 'gross_profit_percentage',
        value: cleanedValue,
        exact: false,
        mappedFrom: 'profit margin',
        displayName: 'Profit Margin'
      };
    }
    
    // As another fallback, try searching raw text directly for profit margin with percentage
    if (pdfData._rawText) {
      const rawText = pdfData._rawText;
      // Look for profit margin followed by a percentage value
      const profitMarginRegex = /(profit\s*margin|net\s*profit\s*%|gross\s*profit\s*%).*?([-+]?\s*\d+\.?\d*\s*%|\([-]?\s*\d+\.?\d*\))/i;
      const match = rawText.match(profitMarginRegex);
      if (match && match[2]) {
        let value = match[2].trim();
        // Check if value is in parentheses format which indicates negative
        if (value.startsWith('(') && value.endsWith(')')) {
          value = '-' + value.substring(1, value.length - 1);
        }
        // Ensure it has % symbol
        if (!value.includes('%')) {
          value = value + '%';
        }
        console.log("Found profit margin in raw text:", value);
        return {
          key: 'profit_margin',
          value: cleanValue(value),
          exact: true,
          fromRawText: true,
          displayName: 'Profit Margin'
        };
      }
      
      // Also look for (-) indicator with profit margin
      const negativeMarginRegex = /profit\s*margin.*?\(?-\)?.*?([\d.]+)/i;
      const negMatch = rawText.match(negativeMarginRegex);
      if (negMatch && negMatch[1]) {
        const value = '-' + negMatch[1].trim() + '%';
        console.log("Found negative profit margin in raw text:", value);
        return {
          key: 'profit_margin',
          value: cleanValue(value),
          exact: true,
          fromRawText: true,
          displayName: 'Profit Margin'
        };
      }
    }
  }
  
  // Handle specific cases for common metrics in Profit & Loss
    // Special case for gross loss b/f which is shown in the screenshot
  if (lowerQuery.includes('gross loss b/f') || lowerQuery.includes('gross loss bf') ||
      lowerQuery.includes('gross loss brought forward')) {
    if (pdfData['gross_loss_bf']) {
      const cleanedValue = cleanValue(pdfData['gross_loss_bf']);
      console.log("Found gross_loss_bf direct match:", cleanedValue);
      return {
        key: 'gross_loss_bf',
        value: cleanedValue,
        exact: true,
        displayName: 'Gross Loss b/f'
      };
    }      // Fallback to checking for gross_loss as it may contain the value
    else if (pdfData['gross_loss']) {
      const cleanedValue = cleanValue(pdfData['gross_loss']);
      console.log("Found gross_loss as fallback for gross loss b/f:", cleanedValue);
      return {
        key: 'gross_loss',
        value: cleanedValue,
        exact: false,
        mappedFrom: 'gross loss b/f',
        displayName: 'Gross Loss b/f'
      };
    }
    
    // If nothing found, try searching in raw text
    if (pdfData._rawText) {
      const rawText = pdfData._rawText;
      const grossLossBfRegex = /(gross\s*loss\s*b\/f|gross\s*loss\s*bf|gross\s*loss\s*brought\s*forward).*?([\d,.]+)/i;
      const match = rawText.match(grossLossBfRegex);
      if (match && match[2]) {
        console.log("Found gross loss b/f in raw text:", match[2]);        return {
          key: 'gross_loss_bf',
          value: cleanValue(match[2]),
          exact: true,
          displayName: 'Gross Loss b/f'
        };
      }
    }
  }
    // Special case for net/nett profit which is commonly requested
  if (lowerQuery.includes('net profit') || lowerQuery.includes('nett profit')) {
    if (pdfData['net_profit']) {
      const cleanedValue = cleanValue(pdfData['net_profit']);
      console.log("Found net_profit direct match:", cleanedValue);
      return {
        key: 'net_profit',
        value: cleanedValue,
        exact: true,
        displayName: 'Net Profit'
      };
    } else if (pdfData['nett_profit']) {
      const cleanedValue = cleanValue(pdfData['nett_profit']);
      console.log("Found nett_profit direct match:", cleanedValue);
      return {
        key: 'nett_profit',
        value: cleanedValue,
        exact: true,
        displayName: 'Nett Profit'
      };
    }
  }
    // Look for exact matches in the extracted data
  for (const key in pdfData) {
    if (key === '_rawText') continue; // Skip the raw text
    
    if (key.toLowerCase().includes(lowerQuery)) {
      const cleanedValue = cleanValue(pdfData[key]);
      console.log(`Found direct match for key ${key}:`, cleanedValue);
      return {
        key,
        value: cleanedValue,
        exact: true,
        displayName: key.replace(/_/g, ' ')
      };
    }
  }
    // Check for common variations in terminology with expanded coverage
  const termVariations = {
    'gross loss b/f': ['gross_loss_bf', 'gross_loss', 'gross_loss_brought_forward'],
    'gross loss bf': ['gross_loss_bf', 'gross_loss'],
    'gross loss brought forward': ['gross_loss_bf', 'gross_loss'],
    'gross loss': ['gross_loss', 'gross_loss_bf'],
    'gross profit': ['gross_profit'],
    'net profit': ['net_profit', 'nett_profit'],
    'nett profit': ['nett_profit', 'net_profit'],
    'net income': ['net_profit', 'nett_profit'],
    'sales': ['sales_accounts', 'sales_account'],
    'revenue': ['sales_accounts', 'sales_account', 'total_income'],
    'income': ['sales_accounts', 'total_income', 'indirect_incomes'],
    'purchases': ['purchase_accounts', 'purchases_account'],
    'expenses': ['direct_expenses', 'indirect_expenses', 'total_expenses'],
    'discount': ['bill_discount', 'special_discount', 'discount'],
    'opening stock': ['opening_stock'],
    'closing stock': ['closing_stock'],
    'raw material': ['raw_material'],
    'freight': ['outward_freight', 'inward_carting'],
    'transportation': ['transportation', 'outward_freight', 'inward_carting'],
    'mobile': ['mobile_expenses'],
    'salary': ['salary_account'],
    'tour': ['tour_expenses'],
    'loading': ['loading_unloading'],
    'godown': ['godown_expenses'],
    'rates and tax': ['rates_tax'],
    'petrol': ['petrol_expense'],
    'commission': ['commission_expenses'],
    'consultancy': ['business_management_and_consultancy']
  };
  
  // Check against variations first
  for (const [term, keys] of Object.entries(termVariations)) {
    if (lowerQuery.includes(term)) {
      for (const key of keys) {
        if (pdfData[key]) {
          console.log(`Found variation match: ${term} -> ${key}:`, pdfData[key]);
          return {
            key,
            value: pdfData[key],
            exact: false,
            mappedFrom: term,
            displayName: key.replace(/_/g, ' ')
          };
        }
      }
    }
  }
  
  // Look for matches using the term mapping
  for (const [userTerm, technicalTerms] of Object.entries(TERM_MAPPING)) {
    if (lowerQuery.includes(userTerm)) {
      console.log(`Found term mapping match: ${userTerm} -> ${technicalTerms.join(', ')}`);
      
      // Try each technical term that might match
      for (const techTerm of technicalTerms) {
        const techTermFormatted = techTerm.toLowerCase().replace(/\s+/g, '_');
        
        // First try direct object property lookup
        for (const key in pdfData) {
          if (key === '_rawText') continue;
          
          if (key.toLowerCase().includes(techTermFormatted)) {
            console.log(`Found key match for ${techTerm} -> ${key}:`, pdfData[key]);
            return {
              key,
              value: pdfData[key],
              exact: false,
              mappedFrom: userTerm,
              displayName: userTerm.charAt(0).toUpperCase() + userTerm.slice(1)
            };
          }
        }            // If we didn't find in the structured data, try regex on the raw text
            const rawText = pdfData._rawText;
            if (rawText) {
              try {
                // More comprehensive regex to catch various formats
                const regexPatterns = [
                  // Standard pattern with label and value
                  new RegExp(`${escapeRegExp(techTerm)}\\s*[:]*\\s*([-+]?[\\d,.]+%?|[-+]?[\\d,.]+\\s*:\\s*[-+]?[\\d,.]+)`, 'i'),
                  // Pattern looking for the term near a value in the line
                  new RegExp(`(.*${escapeRegExp(techTerm)}.*?)([-+]?[\\d,.]+)`, 'i'),
                  // Pattern for terms at the start of lines
                  new RegExp(`^\\s*${escapeRegExp(techTerm)}\\s*.*?([-+]?[\\d,.]+)`, 'im'),
                  // Pattern for detecting lines with just the term, then value in next line
                  new RegExp(`${escapeRegExp(techTerm)}\\s*$\\n\\s*([-+]?[\\d,.]+)`, 'im')
                ];
                
                // Try each pattern
            for (const regex of regexPatterns) {
              const match = rawText.match(regex);
              if (match) {
                console.log(`Found raw text match using regex for ${techTerm}:`, match[1]);
                return {
                  key: techTerm,
                  value: match[1],
                  exact: false,
                  mappedFrom: userTerm,
                  fromRawText: true,
                  displayName: userTerm.charAt(0).toUpperCase() + userTerm.slice(1)
                };
              }
            }
            
            // Special case for searching whole lines containing the term
            const lines = rawText.split('\n');
            for (const line of lines) {
              if (line.toLowerCase().includes(techTerm.toLowerCase())) {
                const numberMatch = line.match(/([-+]?[\d,.]+)/);
                if (numberMatch) {
                  console.log(`Found raw text match by line scanning for ${techTerm}:`, numberMatch[1]);
                  return {
                    key: techTerm,
                    value: numberMatch[1],
                    exact: false,
                    mappedFrom: userTerm,
                    fromRawText: true,
                    displayName: userTerm.charAt(0).toUpperCase() + userTerm.slice(1)
                  };
                }
              }
            }
          } catch (error) {
            console.error("Error in regex search:", error);
          }
        }
      }
    }
  }
  
  // Special case for "Gross Loss b/f" - look for those exact words in raw text
  if (lowerQuery.includes('gross loss b/f')) {
    if (pdfData._rawText) {
      try {
        const rawText = pdfData._rawText;
        const lines = rawText.split('\n');
        
        // Look for lines with "Gross Loss" or "Gross Loss b/f"
        const grossLossLines = lines.filter(line => 
          line.toLowerCase().includes('gross loss')
        );
        
        if (grossLossLines.length > 0) {
          console.log("Found lines with 'Gross Loss':", grossLossLines);
          
          // Try to extract a number from these lines
          for (const line of grossLossLines) {
            const numberMatch = line.match(/([-+]?[\d,.]+)/);
            if (numberMatch) {
              console.log("Extracted Gross Loss value:", numberMatch[1]);
              return {
                key: 'gross_loss_bf',
                value: numberMatch[1],
                exact: false,
                fromRawText: true,
                displayName: 'Gross Loss b/f'
              };
            }
          }
        }
      } catch (error) {
        console.error("Error in special case search for 'Gross Loss b/f':", error);
      }
    }
  }
  
  // Last resort - try a direct search in the raw text for the exact query terms
  if (pdfData._rawText) {
    try {
      const rawText = pdfData._rawText;
      const lines = rawText.split('\n');
      
      // First pass - look for lines containing the query term exactly as entered
      const matchingLines = lines.filter(line => 
        line.toLowerCase().includes(lowerQuery)
      );
      
      if (matchingLines.length > 0) {
        console.log("Found matching lines for direct search:", matchingLines);
        
        // Try to extract a number from the first matching line
        for (const line of matchingLines) {
          const numberMatch = line.match(/([-+]?[\d,.]+)/);
          if (numberMatch) {
            console.log("Extracted value from matching line:", numberMatch[1]);
            return {
              key: query,
              value: numberMatch[1],
              exact: false,
              directTextMatch: true,
              displayName: query
            };
          }
        }
      }
      
      // If no exact matches, try tokenizing the query and look for lines 
      // that contain most of the significant words
      const queryTokens = lowerQuery.split(/\W+/).filter(t => t.length > 2 && !['the', 'and', 'for', 'from', 'with', 'what', 'tell', 'show', 'give'].includes(t));
      
      if (queryTokens.length > 0) {
        console.log("Searching using query tokens:", queryTokens);
        
        // Score each line by how many tokens it contains
        const scoredLines = lines.map(line => {
          const lowLine = line.toLowerCase();
          const score = queryTokens.filter(token => lowLine.includes(token)).length;
          return { line, score };
        }).filter(item => item.score > 0)
          .sort((a, b) => b.score - a.score);
        
        if (scoredLines.length > 0) {
          console.log("Found lines matching query tokens:", 
                     scoredLines.slice(0, 3).map(item => `${item.line} (score: ${item.score})`));
          
          // Try to extract a number from the highest scoring lines
          for (const {line} of scoredLines.slice(0, 3)) {
            const numberMatch = line.match(/([-+]?[\d,.]+)/);
            if (numberMatch) {
              const bestMatchingToken = queryTokens.find(token => line.toLowerCase().includes(token)) || query;
              console.log("Extracted value from token-matching line:", numberMatch[1]);
              return {
                key: bestMatchingToken,
                value: numberMatch[1],
                exact: false,
                tokenMatch: true,
                displayName: bestMatchingToken.charAt(0).toUpperCase() + bestMatchingToken.slice(1)
              };
            }
          }
        }
      }
    } catch (error) {
      console.error("Error in direct text search:", error);
    }
  }
    // Try token-based matching as a last resort
  const tokenMatch = tokenBasedMetricMatch(query, pdfData);
  if (tokenMatch) {
    console.log(`Found token-based match for "${query}":`, tokenMatch);
    return tokenMatch;
  }
  
  // No match found
  console.log("No match found for metric:", query);
  return null;
}

// Function to perform token-based matching for metrics when other methods fail
function tokenBasedMetricMatch(query, pdfData) {
  if (!query || !pdfData) return null;
  
  // Tokenize the query
  const queryTokens = query.toLowerCase()
    .split(/\s+/)
    .filter(token => token.length > 2 && !['and', 'the', 'for', 'from'].includes(token));
  
  console.log("Token-based matching with tokens:", queryTokens);
  
  // Calculate match scores for each key in the data
  const scores = {};
  for (const key in pdfData) {
    if (key === '_rawText') continue;
    
    // Convert key to display format and tokenize
    const displayKey = key.replace(/_/g, ' ');
    const keyTokens = displayKey.split(/\s+/);
    
    // Count matching tokens
    let matchScore = 0;
    for (const queryToken of queryTokens) {
      if (keyTokens.some(keyToken => keyToken.includes(queryToken) || queryToken.includes(keyToken))) {
        matchScore++;
      }
    }
    
    // Store score if at least one token matched
    if (matchScore > 0) {
      scores[key] = {
        score: matchScore / queryTokens.length, // Normalize by query length
        key: key,
        value: pdfData[key],
        displayName: key.replace(/_/g, ' ')
      };
    }
  }
  
  // Find the best match
  let bestMatch = null;
  let highestScore = 0;
  
  for (const key in scores) {
    if (scores[key].score > highestScore) {
      highestScore = scores[key].score;
      bestMatch = scores[key];
    }
  }
  
  // Return the best match if score is at least 0.5 (50% of tokens matched)
  if (bestMatch && highestScore >= 0.5) {
    console.log(`Token-based match found: ${bestMatch.key} with score ${highestScore}`);
    return {
      key: bestMatch.key,
      value: bestMatch.value,
      exact: false,
      score: highestScore,
      displayName: bestMatch.displayName
    };
  }
  
  return null;
}

// Helper to escape special characters in regex
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Function to detect which report type a query is referring to
export function detectReportTypeFromQuery(query) {
  const lowerQuery = query.toLowerCase();
    // First, check if specific P&L metrics like "gross loss b/f" are mentioned
  // These should be directed to profit & loss report
  const plSpecificTerms = [
    'gross loss b/f', 'gross loss bf', 'gross loss brought forward',
    'gross profit b/f', 'gross profit bf',
    'bill discount', 'finish goods', 'opening stock', 'closing stock',
    'raw material', 'purchase accounts', 'sales accounts', 'direct expenses',
    'godown', 'carting', 'loading', 'outward freight', 'sales promotion',
    'indirect expenses', 'commission', 'petrol expense', 'rates & tax',
    'tour exp', 'transportation', 'salary account'
  ];
  
  for (const term of plSpecificTerms) {
    if (lowerQuery.includes(term)) {
      console.log(`Detected P&L report from specific term: ${term}`);
      return 'profit_and_loss_report';
    }
  }
  
  // Check each report type's keywords
  for (const [reportType, keywords] of Object.entries(REPORT_TYPE_KEYWORDS)) {
    let matchCount = 0;
    
    for (const keyword of keywords) {
      if (lowerQuery.includes(keyword)) {
        matchCount++;
      }
    }
    
    if (matchCount > 0) {
      console.log(`Detected ${reportType} with ${matchCount} keyword matches`);
      return reportType;
    }
  }
  
  // If no clear match, try to infer from the metrics being asked about
  for (const [userTerm, technicalTerms] of Object.entries(TERM_MAPPING)) {
    if (lowerQuery.includes(userTerm)) {
      // Check which report is most likely to contain this metric
      if (userTerm.includes('ratio') || userTerm.includes('turnover') || userTerm.includes('return on')) {
        console.log(`Inferred ratio_analysis_report from metric: ${userTerm}`);
        return 'ratio_analysis_report';
      }
      
      if (userTerm.includes('cash') || userTerm.includes('flow')) {
        // Determine if it's a projection or statement
        if (lowerQuery.includes('projection') || lowerQuery.includes('forecast')) {
          console.log(`Inferred cash_flow_projection_report from metric: ${userTerm}`);
          return 'cash_flow_projection_report';
        } else {
          console.log(`Inferred cash_flow_statement_report from metric: ${userTerm}`);
          return 'cash_flow_statement_report';
        }
      }
      
      if (userTerm.includes('expense') || userTerm.includes('spending') || 
          userTerm.includes('cost') || userTerm.includes('expenditure')) {
        console.log(`Inferred expense_analysis_report from metric: ${userTerm}`);
        return 'expense_analysis_report';
      }
      
      // Default to profit & loss as the most common report        matchCount++;
      }
    }
    
    if (matchCount > 0) {
      console.log(`Detected ${reportType} with ${matchCount} keyword matches`);
      return reportType;
    }
    
    console.log(`Could not detect report type from query`);
    return null;
  }
  
  // If no clear match, try to infer from the metrics being asked about
  for (const [userTerm, technicalTerms] of Object.entries(TERM_MAPPING)) {
    if (lowerQuery.includes(userTerm)) {Request,
      // Check which report is most likely to contain this metricy,
      if (userTerm.includes('ratio') || userTerm.includes('turnover') || userTerm.includes('return on')) {
        console.log(`Inferred ratio_analysis_report from metric: ${userTerm}`);
        return 'ratio_analysis_report';
      }ate
      {
      if (userTerm.includes('cash') || userTerm.includes('flow')) {try {
        // Determine if it's a projection or statementTALLY_URL, tallyRequest, {
        if (lowerQuery.includes('projection') || lowerQuery.includes('forecast')) {
          console.log(`Inferred cash_flow_projection_report from metric: ${userTerm}`);
          return 'cash_flow_projection_report';
        } else {    if (response && response.data) {
          console.log(`Inferred cash_flow_statement_report from metric: ${userTerm}`);ess: "new" });
          return 'cash_flow_statement_report';age = await browser.newPage();
        }e.setContent(response.data, { waitUntil: "networkidle0" });
      }nst pdfBuffer = await page.pdf({
      ", 
      if (userTerm.includes('expense') || userTerm.includes('spending') || pe: true, 
          userTerm.includes('cost') || userTerm.includes('expenditure')) {gin: { top: "10mm", right: "5mm", bottom: "10mm", left: "5mm" },
        console.log(`Inferred expense_analysis_report from metric: ${userTerm}`);printBackground: true
        return 'expense_analysis_report';  });
      }wait browser.close();
      
      // Default to profit & loss as the most common report
      const parsedData = await parsePDFContent(pdfBuffer, reportName);
      
      // Upload the PDF to S3
      await uploadFileToS3(pdfBuffer, s3Key, "application/pdf");
      const s3Url = `https://${process.env.TALLY_AWS_BUCKET_NAME}.s3.${process.env.AWS_REGION}.amazonaws.com/${s3Key}`;
      console.log(`${reportName} PDF uploaded to S3:`, s3Url);

      const downloadUrl = `${process.env.BACKEND_BASE_URL}/api/download/${reportName}/${fromDate}/${toDate}`;

      return {
        message: replyMessage,
        downloadUrl,
        parsedData // Include the parsed data in the response
      };
    } else {
      throw new Error("No data received from Tally");
    }
  } catch (error) {
    console.error(`Error fetching or processing ${reportName} report:`, error.message);
    if (error.response) {
      console.error("Status:", error.response.status);
      console.error("Data:", error.response.data);
    }
    throw error;
  }
}